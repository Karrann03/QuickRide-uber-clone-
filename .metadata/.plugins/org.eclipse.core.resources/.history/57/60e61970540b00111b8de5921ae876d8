package com.kv.service;

import java.time.LocalDateTime;
import java.util.List;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import com.kv.RideStatus.DriverStatus;
import com.kv.RideStatus.RideStatus;
import com.kv.RideStatus.VehicleType;
import com.kv.dto.RideRequestDto;
import com.kv.dto.RideResponseDto;
import com.kv.entity.DriverEntity;
import com.kv.entity.RideEntity;
import com.kv.entity.UserEntity;
import com.kv.repository.DriverRepository;
import com.kv.repository.RideRepository;
import com.kv.repository.UserRepository;

@Service
public class RideServiceImpl implements IRideService {

	@Autowired
	private UserRepository userRepo;
	
	@Autowired
	private RideRepository rideRepo;
	
	@Autowired
	private DriverRepository driverRepo;
	
	@Override
	public RideResponseDto requestRide(RideRequestDto request) {
		
		// Fetch User
		UserEntity user = userRepo.findById(request.getUserId()).orElseThrow(() -> new RuntimeException("User Not Found"));
		
		//Fetch All Available Drivers
		DriverEntity nearestDriver = findNearestDriver(request.getPickupLat(), request.getPickupLong(), request.getVehicleType());
		 
		if (nearestDriver == null) {
	            throw new RuntimeException("No available driver found");
	        } else {
	       
	        }
		
		RideEntity ride = new RideEntity();
		ride.setUser(user);
		ride.setDriver(nearestDriver);
		ride.setPickupLat(request.getPickupLat());
	    ride.setPickupLong(request.getPickupLong());
	    ride.setDropLat(request.getDropLat());
	    ride.setDropLong(request.getDropLong());
	    ride.setStatus(RideStatus.REQUESTED);
	    ride.setCreatedAt(LocalDateTime.now());
	    
	    // Calculate distance & fare
        double distanceKm = haversineDistance(request.getPickupLat(), request.getPickupLong(), request.getDropLat(), request.getDropLong());
        double fare = calculateFare(distanceKm, request.getVehicleType());

        rideRepo.save(ride);
        
        // Update driver availability
        nearestDriver.setStatus(DriverStatus.ONTRIP);
        driverRepo.save(nearestDriver);
	    
        RideResponseDto response = new RideResponseDto();
        response.setRideId(ride.getId());
        response.setDriverId(nearestDriver.getId());
        response.setUserId(user.getId());
        response.setStatus(ride.getStatus().toString());
        response.setPickupLat(request.getPickupLat());
        response.setPickupLong(request.getPickupLong());
        response.setDropLat(request.getDropLat());
        response.setDropLong(request.getDropLong());
        response.setDistanceKm(distanceKm);
        response.setFare(fare);
        response.setVehicleType(request.getVehicleType());

        return response;
	}
	
	
	
	
	public DriverEntity findNearestDriver(double pickupLat, double pickupLong, VehicleType vehicleType) {
	
		  List<DriverEntity> availableDrivers =
	                driverRepo.findByStatusAndVehicleType(
	                        DriverStatus.AVAILABLE,
	                        vehicleType);

	        if (availableDrivers.isEmpty()) {
	            return null;
	        }
		DriverEntity nearest = null;
	    double minDistance = Double.MAX_VALUE;

	    for (DriverEntity driver : availableDrivers) {
	        double distance = haversineDistance(pickupLat, pickupLong, driver.getCurrentLat(), driver.getCurrentLong());
	       
	        
	        
	        if (distance < minDistance) {
	            minDistance = distance;
	            nearest = driver;
	        }
	    }
	    return nearest;
	}

	private double haversineDistance(double lat1, double lon1, double lat2, double lon2) {
	    final int R = 6371; // Earth radius in km
	    double latDistance = Math.toRadians(lat2 - lat1);
	    double lonDistance = Math.toRadians(lon2 - lon1);
	    double a = Math.sin(latDistance / 2) * Math.sin(latDistance / 2)
	             + Math.cos(Math.toRadians(lat1)) * Math.cos(Math.toRadians(lat2))
	             * Math.sin(lonDistance / 2) * Math.sin(lonDistance / 2);
	    double c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
	    return R * c;
	}

    // Fare calculation based on distance & vehicle type
    private double calculateFare(double distanceKm, VehicleType vehicleType) {
        double baseFare = 50; // base fare
        double perKmRate = 10; // default

        switch (vehicleType) {
            case MINI_UV -> perKmRate = 10;
            case SEDAN -> perKmRate = 15;
            case SUV -> perKmRate = 20;
        }

        return baseFare + (perKmRate * distanceKm);
    }

}
